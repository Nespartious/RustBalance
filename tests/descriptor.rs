//! Tests for descriptor parsing and building

#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(clippy::expect_used)] // Tests use expect for clarity

use rustbalance::crypto::{DescriptorBuilder, MasterIdentity};
use rustbalance::tor::descriptors::LinkSpecifier;
use rustbalance::tor::{HsDescriptor, IntroductionPoint};

/// Test descriptor decryption using a stem-generated descriptor with known keys
///
/// Keys generated by create_test_descriptor.py:
/// - identity_key: db995fe25169d141cab9bbba92baa01f9f2e1ece7df4cb2ac05190f37fcc1f9d
/// - blinded_key: c8899950c2c0d0b8036afb7fd915b6a0007d5d42961fd3ca4a5918c860b21ff3
/// - subcredential: c8b554026c31849479c41cb9d0a15117a652ff6dd79d6c860b7f881390c83023
/// - revision_counter: 12345
#[test]
fn test_decrypt_stem_generated_descriptor() {
    // Test subcredential derivation first
    let identity_key_bytes =
        hex::decode("db995fe25169d141cab9bbba92baa01f9f2e1ece7df4cb2ac05190f37fcc1f9d").unwrap();
    let blinded_key_bytes =
        hex::decode("c8899950c2c0d0b8036afb7fd915b6a0007d5d42961fd3ca4a5918c860b21ff3").unwrap();
    let expected_subcred =
        hex::decode("c8b554026c31849479c41cb9d0a15117a652ff6dd79d6c860b7f881390c83023").unwrap();

    // Convert to arrays
    let mut identity_key = [0u8; 32];
    identity_key.copy_from_slice(&identity_key_bytes);
    let mut blinded_key = [0u8; 32];
    blinded_key.copy_from_slice(&blinded_key_bytes);

    // Create VerifyingKey from identity key bytes
    let identity_pubkey =
        ed25519_dalek::VerifyingKey::from_bytes(&identity_key).expect("valid key");

    // Derive subcredential
    let subcredential = rustbalance::crypto::derive_subcredential(&identity_pubkey, &blinded_key);

    // Verify subcredential matches
    assert_eq!(
        subcredential.to_vec(),
        expected_subcred,
        "Subcredential mismatch: got {}, expected {}",
        hex::encode(&subcredential),
        hex::encode(&expected_subcred)
    );

    println!("Subcredential derivation verified!");
}

/// Test layer decryption with known values from stem-generated descriptor
#[test]
fn test_decrypt_layer_known_values() {
    use rustbalance::crypto::decrypt_layer;

    // Values from verify_parsing.py output
    let blinded_key: [u8; 32] =
        hex::decode("c8899950c2c0d0b8036afb7fd915b6a0007d5d42961fd3ca4a5918c860b21ff3")
            .unwrap()
            .try_into()
            .unwrap();
    let subcredential: [u8; 32] =
        hex::decode("c8b554026c31849479c41cb9d0a15117a652ff6dd79d6c860b7f881390c83023")
            .unwrap()
            .try_into()
            .unwrap();
    let revision_counter: u64 = 12345;

    // First 100 bytes of encrypted body (salt + partial ciphertext + partial mac would be wrong,
    // so we need the full blob)
    // For a proper test, we'd load the test_descriptor.txt file
    // For now, test with a minimal synthetic case

    // Create a minimal test case - encrypt something ourselves and decrypt it
    // This tests that our decrypt_layer works correctly

    println!("Layer decryption test - would need full encrypted blob");
    // The real test would load test_descriptor.txt and decrypt it
}

#[test]
fn test_parse_v3_descriptor_outer() {
    // Parse the outer layer of a v3 descriptor
    // Cert format: VERSION(1) | CERT_TYPE(1) | EXPIRATION(4) | KEY_TYPE(1) | CERTIFIED_KEY(32) |
    //              N_EXTENSIONS(1) | EXTENSIONS... | SIGNATURE(64)
    // For type 0x08 (BLINDED_ID_V_SIGNING), the blinded key is in extension type 0x04
    // Extension format: ExtLen(2) | ExtType(1) | ExtFlags(1) | ExtData(ExtLen)
    let cert_b64 = {
        let mut cert = Vec::new();
        cert.push(0x01); // VERSION
        cert.push(0x08); // CERT_TYPE = BLINDED_ID_V_SIGNING
        cert.extend_from_slice(&[0x00, 0x00, 0x00, 0x00]); // EXPIRATION (4 bytes)
        cert.push(0x01); // KEY_TYPE = Ed25519
        cert.extend_from_slice(&[0xBB; 32]); // CERTIFIED_KEY (signing key, not blinded)
        cert.push(0x01); // N_EXTENSIONS = 1
                         // Extension: signed-with-ed25519-key (type 0x04)
        cert.extend_from_slice(&[0x00, 0x20]); // ExtLen = 32
        cert.push(0x04); // ExtType = signed-with-ed25519-key
        cert.push(0x00); // ExtFlags
        cert.extend_from_slice(&[0xAA; 32]); // ExtData = blinded key
        cert.extend_from_slice(&[0x00; 64]); // SIGNATURE (placeholder)
        use base64::{engine::general_purpose::STANDARD, Engine};
        STANDARD.encode(&cert)
    };

    let raw = format!(
        r#"hs-descriptor 3
descriptor-lifetime 180
descriptor-signing-key-cert
-----BEGIN ED25519 CERT-----
{}
-----END ED25519 CERT-----
revision-counter 1
superencrypted
-----BEGIN MESSAGE-----
AQIDBA==
-----END MESSAGE-----
signature AAAA
"#,
        cert_b64
    );

    let desc = HsDescriptor::parse(&raw).expect("parse failed");
    assert_eq!(desc.version, 3);
    assert_eq!(desc.lifetime, 180);
    assert_eq!(desc.revision_counter, 1);
    assert_eq!(desc.blinded_key, [0xAA; 32]);
}

#[test]
fn test_descriptor_builder() {
    // Test that we can build a descriptor
    let seed = [42u8; 32];
    let identity = MasterIdentity::from_seed(&seed);

    let builder = DescriptorBuilder::new(&identity, 1);

    // Create test intro points
    let mut id = [0u8; 32];
    id[0] = 1;
    let ip = IntroductionPoint {
        link_specifiers: vec![LinkSpecifier::Ed25519Id(id)],
        onion_key: [0x11; 32],
        auth_key_cert: vec![],
        enc_key: [0x22; 32],
        enc_key_cert: vec![],
    };

    let output = builder.build(&[ip]).expect("build failed");

    // Verify structure
    assert!(output.descriptor.contains("hs-descriptor 3"));
    assert!(output.descriptor.contains("revision-counter 1"));
    assert!(output.descriptor.contains("signature"));
    assert!(!output.blinded_key.iter().all(|&b| b == 0));
    assert!(!output.subcredential.iter().all(|&b| b == 0));
}

#[test]
fn test_descriptor_freshness() {
    // Newer revision counter should be considered fresher
}

#[test]
fn test_descriptor_validity_window() {
    // Descriptor should be valid within lifetime, invalid after
}

#[test]
fn test_intro_point_parsing() {
    // Parse introduction points from decrypted descriptor body
}

#[test]
fn test_onion_address_derivation() {
    // Public key should derive correct .onion address
    // Reference: rend-spec-v3 ยง6.1
    let seed = [0u8; 32];
    let identity = MasterIdentity::from_seed(&seed);
    let addr = identity.onion_address();

    // Onion addresses are always lowercase
    assert!(addr.to_lowercase().ends_with(".onion"));
    assert_eq!(addr.len(), 62); // 56 base32 chars + ".onion"
}

#[test]
fn test_blinding_deterministic() {
    // Same key + time period should produce same blinded key
    use ed25519_dalek::SigningKey;
    use rustbalance::crypto::blind_identity;

    let seed = [1u8; 32];
    let signing_key = SigningKey::from_bytes(&seed);
    let public_key = signing_key.verifying_key();

    let blind1 = blind_identity(&public_key, 1000, None);
    let blind2 = blind_identity(&public_key, 1000, None);

    assert_eq!(blind1, blind2);
}

#[test]
fn test_blinding_varies_by_period() {
    // Different time periods should produce different blinded keys
    use ed25519_dalek::SigningKey;
    use rustbalance::crypto::blind_identity;

    let seed = [1u8; 32];
    let signing_key = SigningKey::from_bytes(&seed);
    let public_key = signing_key.verifying_key();

    // Use timestamps far apart (different 24h periods)
    // Time period length is 86400 seconds (24 hours)
    let blind1 = blind_identity(&public_key, 86400, None); // Period 1
    let blind2 = blind_identity(&public_key, 86400 * 2, None); // Period 2

    assert_ne!(blind1, blind2);
}

#[test]
fn test_subcredential_derivation() {
    // Subcredential should match Tor's computation
    // Reference: rend-spec-v3 ยง2.1
    use ed25519_dalek::SigningKey;
    use rustbalance::crypto::{blind_identity, derive_subcredential};

    let seed = [1u8; 32];
    let signing_key = SigningKey::from_bytes(&seed);
    let public_key = signing_key.verifying_key();

    let blind = blind_identity(&public_key, 1000, None);
    let subcred = derive_subcredential(&public_key, &blind);

    // Should be non-zero
    assert!(!subcred.iter().all(|&b| b == 0));
    // Should be deterministic
    let subcred2 = derive_subcredential(&public_key, &blind);
    assert_eq!(subcred, subcred2);
}
